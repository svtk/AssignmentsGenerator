{
  "summary" : "Assignment for Week 5 of the Coursera <a href=\"https://www.coursera.org/learn/kotlin-for-java-developers/\">Kotlin for Java Developers</a> course",
  "title" : "Kotlin for Java Developers. Week 5",
  "programming_language" : "kotlin",
  "language" : "en",
  "items" : [ {
    "id" : 0,
    "title" : "Games",
    "unit_id" : 0,
    "task_list" : [ {
      "name" : "Task",
      "stepic_id" : 0,
      "task_files" : {
        "src/board/Board.kt" : {
          "name" : "src/board/Board.kt",
          "text" : "package board\n\ninterface Cell {\n    val i: Int\n    val j: Int\n}\n\nenum class Direction {\n    UP, DOWN, RIGHT, LEFT;\n\n    fun reversed() = when (this) {\n        UP -> DOWN\n        DOWN -> UP\n        RIGHT -> LEFT\n        LEFT -> RIGHT\n    }\n}\n\ninterface SquareBoard {\n    val width: Int\n\n    fun getCellOrNull(i: Int, j: Int): Cell?\n    fun getCell(i: Int, j: Int): Cell\n\n    fun getAllCells(): Collection<Cell>\n\n    fun getRow(i: Int, jRange: IntProgression): List<Cell>\n    fun getColumn(iRange: IntProgression, j: Int): List<Cell>\n\n    fun Cell.getNeighbour(direction: Direction): Cell?\n}\n\ninterface GameBoard<T> : SquareBoard {\n\n    operator fun get(cell: Cell): T?\n    operator fun set(cell: Cell, value: T?)\n\n    fun filter(predicate: (T?) -> Boolean): Collection<Cell>\n    fun find(predicate: (T?) -> Boolean): Cell?\n    fun any(predicate: (T?) -> Boolean): Boolean\n    fun all(predicate: (T?) -> Boolean): Boolean\n}",
          "placeholders" : [ ]
        },
        "src/board/BoardImpl.kt" : {
          "name" : "src/board/BoardImpl.kt",
          "text" : "package board\n\nimport board.Direction.*\n\nfun createSquareBoard(width: Int): SquareBoard = TODO()\nfun <T> createGameBoard(width: Int): GameBoard<T> = TODO()\n\n",
          "placeholders" : [ {
            "offset" : 90,
            "length" : 6,
            "hints" : [ ],
            "placeholder_text" : "TODO()"
          }, {
            "offset" : 149,
            "length" : 6,
            "hints" : [ ],
            "placeholder_text" : "TODO()"
          } ]
        },
        "src/games/game/Game.kt" : {
          "name" : "src/games/game/Game.kt",
          "text" : "package games.game\n\nimport board.Direction\n\ninterface Game {\n    fun initialize()\n    fun canMove(): Boolean\n    fun hasWon(): Boolean\n    fun processMove(direction: Direction)\n    operator fun get(i: Int, j: Int): Int?\n}\n",
          "placeholders" : [ ]
        },
        "src/games/game2048/Game2048.kt" : {
          "name" : "src/games/game2048/Game2048.kt",
          "text" : "package games.game2048\n\nimport board.Cell\nimport board.Direction\nimport board.GameBoard\nimport board.createGameBoard\nimport games.game.Game\n\n/*\n * Your task is to implement the game 2048 https://en.wikipedia.org/wiki/2048_(video_game)\n * Implement the utility methods below.\n *\n * After implementing it you can try to play the game executing 'PlayGame2048'\n * (or choosing the corresponding run configuration).\n */\nfun newGame2048(initializer: Game2048Initializer<Int> = RandomGame2048Initializer): Game =\n        Game2048(initializer)\n\nclass Game2048(private val initializer: Game2048Initializer<Int>) : Game {\n    private val board = createGameBoard<Int?>(4)\n\n    override fun initialize() {\n        repeat(2) {\n            board.addNewValue(initializer)\n        }\n    }\n\n    override fun canMove() = board.any { it == null }\n\n    override fun hasWon() = board.any { it == 2048 }\n\n    override fun processMove(direction: Direction) {\n        if (board.moveValues(direction)) {\n            board.addNewValue(initializer)\n        }\n    }\n\n    override fun get(i: Int, j: Int): Int? = board.run { get(getCell(i, j)) }\n}\n\n/*\n * Add a new value produced by 'initializer' to a specified cell in a board.\n */\nfun GameBoard<Int?>.addNewValue(initializer: Game2048Initializer<Int>) {\n    TODO()\n}\n\n/*\n * Move values in a specified rowOrColumn only.\n * Use the helper function 'moveAndMergeEqual' (in Game2048Helper.kt).\n * The values should be moved to the beginning of the row (or column), in the same manner as in the function 'moveAndMergeEqual'.\n * Return 'true' if the values were moved and 'false' otherwise.\n */\nfun GameBoard<Int?>.moveValuesInRowOrColumn(rowOrColumn: List<Cell>): Boolean {\n    TODO()\n}\n\n/*\n * Move values by the rules of the 2048 game to the specified direction.\n * Use the 'moveValuesInRowOrColumn' function above.\n * Return 'true' if the values were moved and 'false' otherwise.\n */\nfun GameBoard<Int?>.moveValues(direction: Direction): Boolean {\n    TODO()\n}",
          "placeholders" : [ {
            "offset" : 1281,
            "length" : 6,
            "hints" : [ ],
            "placeholder_text" : "TODO()"
          }, {
            "offset" : 1696,
            "length" : 6,
            "hints" : [ ],
            "placeholder_text" : "TODO()"
          }, {
            "offset" : 1972,
            "length" : 6,
            "hints" : [ ],
            "placeholder_text" : "TODO()"
          } ]
        },
        "src/games/game2048/Game2048Helper.kt" : {
          "name" : "src/games/game2048/Game2048Helper.kt",
          "text" : "package games.game2048\n\n/*\n * This function moves all the non-null elements to the beginning of the list (by removing nulls) and merges equal elements.\n * The parameter 'double' specifies the way how to merge equal elements:\n * it returns a new element that should be present in the result list instead of two merged elements.\n *\n * If the function double(\"a\") returns \"aa\",\n * then the function moveAndMergeEqual transforms the input in the following way:\n *   a, a, b -> aa, b\n *   a, null -> a\n *   b, null, a, a -> b, aa\n *   a, a, null, a -> aa, a\n *   a, null, a, a -> aa, a\n*/\nfun <T : Any> List<T?>.moveAndMergeEqual(double: (T) -> T): List<T> =\n        TODO()\n\n",
          "placeholders" : [ {
            "offset" : 662,
            "length" : 6,
            "hints" : [ ],
            "placeholder_text" : "TODO()"
          } ]
        },
        "src/games/game2048/Game2048Initializer.kt" : {
          "name" : "src/games/game2048/Game2048Initializer.kt",
          "text" : "package games.game2048\n\nimport board.Cell\nimport board.GameBoard\nimport java.util.*\n\ninterface Game2048Initializer<T> {\n    fun nextValue(board: GameBoard<T?>): Pair<Cell, T>?\n}\n\nobject RandomGame2048Initializer: Game2048Initializer<Int> {\n    private val random = Random()\n    private fun generateRandomStartValue(): Int =\n            if (random.nextInt(10) == 9) 4 else 2\n\n    /*\n     * Generate a random value and a random cell (among free cells)\n     * that given value should be added to.\n     * The value should be 2 for 90% cases, and 4 for the rest of the cases.\n     * Use the 'generateRandomStartValue' function above.\n     * If the board is full return null.\n     */\n    override fun nextValue(board: GameBoard<Int?>): Pair<Cell, Int>? {\n        TODO()\n    }\n}",
          "placeholders" : [ {
            "offset" : 757,
            "length" : 6,
            "hints" : [ ],
            "placeholder_text" : "TODO()"
          } ]
        },
        "src/games/gameOfFifteen/GameOfFifteen.kt" : {
          "name" : "src/games/gameOfFifteen/GameOfFifteen.kt",
          "text" : "package games.gameOfFifteen\n\nimport board.Direction\nimport board.GameBoard\nimport board.createGameBoard\nimport games.game.Game\n\n/*\n * Implement the Game of Fifteen (https://en.wikipedia.org/wiki/15_puzzle).\n * When you finish, you can play the game by executing 'PlayGameOfFifteen'\n * (or choosing the corresponding run configuration).\n */\nfun newGameOfFifteen(initializer: GameOfFifteenInitializer = RandomGameInitializer()): Game =\n    TODO()\n\n",
          "placeholders" : [ {
            "offset" : 438,
            "length" : 6,
            "hints" : [ ],
            "placeholder_text" : "TODO()"
          } ]
        },
        "src/games/gameOfFifteen/GameOfFifteenHelper.kt" : {
          "name" : "src/games/gameOfFifteen/GameOfFifteenHelper.kt",
          "text" : "package games.gameOfFifteen\n\n/*\n * This function should return the parity of the permutation.\n * true - the permutation is even\n * false - the permutation is odd\n * https://en.wikipedia.org/wiki/Parity_of_a_permutation\n\n * If the game of fifteen is started with the wrong parity, you can't get the correct result\n *   (numbers sorted in the right order, empty cell at last).\n * Thus the initial permutation should be correct.\n */\nfun isEven(permutation: List<Int>): Boolean {\n    TODO()\n}",
          "placeholders" : [ {
            "offset" : 480,
            "length" : 6,
            "hints" : [ ],
            "placeholder_text" : "TODO()"
          } ]
        },
        "src/games/gameOfFifteen/GameOfFifteenInitializer.kt" : {
          "name" : "src/games/gameOfFifteen/GameOfFifteenInitializer.kt",
          "text" : "package games.gameOfFifteen\n\nimport java.util.*\n\ninterface GameOfFifteenInitializer {\n    /*\n     * Even permutation of numbers 1..15\n     * used to initialized first 15 cells on a board\n     * (the last cell is empty)\n     */\n    val initialPermutation: List<Int>\n}\n\nclass RandomGameInitializer : GameOfFifteenInitializer {\n    override val initialPermutation by lazy {\n        TODO()\n    }\n}\n\n",
          "placeholders" : [ {
            "offset" : 379,
            "length" : 6,
            "hints" : [ ],
            "placeholder_text" : "TODO()"
          } ]
        },
        "src/games/ui/PlayGame.kt" : {
          "name" : "src/games/ui/PlayGame.kt",
          "text" : "// drawing based on https://github.com/bulenkov/2048\npackage games.ui\n\nimport board.Direction\nimport games.game.Game\nimport java.awt.*\nimport java.awt.event.KeyAdapter\nimport java.awt.event.KeyEvent\nimport javax.swing.JFrame\nimport javax.swing.JPanel\nimport javax.swing.WindowConstants\n\nclass PlayGame(val game: Game, val settings: GameSettings) : JPanel() {\n    init {\n        isFocusable = true\n        addKeyListener(object : KeyAdapter() {\n            override fun keyPressed(e: KeyEvent) {\n                if (game.hasWon() == false && game.canMove()) {\n                    val direction = when (e.keyCode) {\n                        KeyEvent.VK_LEFT -> Direction.LEFT\n                        KeyEvent.VK_RIGHT -> Direction.RIGHT\n                        KeyEvent.VK_DOWN -> Direction.DOWN\n                        KeyEvent.VK_UP -> Direction.UP\n                        else -> null\n                    }\n                    if (direction != null) {\n                        game.processMove(direction)\n                    }\n                }\n                repaint()\n            }\n        })\n        game.initialize()\n    }\n\n    override fun paint(g: Graphics) {\n        super.paint(g)\n        g.color = settings.backgroundColor\n        g.fillRect(0, 0, this.size.width, this.size.height)\n        for (y in 1..4) {\n            for (x in 1..4) {\n                drawTile(g as Graphics2D, game[y, x] ?: 0, x - 1, y - 1)\n            }\n        }\n    }\n\n    private fun offsetCoors(arg: Int): Int {\n        return arg * (TILES_MARGIN + TILE_SIZE) + TILES_MARGIN\n    }\n\n    private fun drawTile(g: Graphics2D, value: Int, x: Int, y: Int) {\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON)\n        g.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE)\n\n        val xOffset = offsetCoors(x)\n        val yOffset = offsetCoors(y)\n        g.color = settings.getBackgroundColor(value)\n        g.fillRoundRect(xOffset, yOffset, TILE_SIZE, TILE_SIZE, 14, 14)\n        g.color = settings.getForegroundColor(value)\n        val size = if (value < 100) 36 else if (value < 1000) 32 else 24\n        val font = Font(FONT_NAME, Font.BOLD, size)\n        g.font = font\n\n        val s = value.toString()\n        val fm = getFontMetrics(font)\n\n        val w = fm.stringWidth(s)\n        val h = -fm.getLineMetrics(s, g).baselineOffsets[2].toInt()\n\n        if (value != 0)\n            g.drawString(s, xOffset + (TILE_SIZE - w) / 2, yOffset + TILE_SIZE - (TILE_SIZE - h) / 2 - 2)\n\n        if (game.hasWon() || game.canMove() == false) {\n            g.color = Color(255, 255, 255, 30)\n            g.fillRect(0, 0, width, height)\n            g.color = Color(78, 139, 202)\n            g.font = Font(FONT_NAME, Font.BOLD, 48)\n            if (game.hasWon()) {\n                g.drawString(\"You won!\", 68, 150)\n            }\n            if (!game.canMove()) {\n                g.drawString(\"Game over!\", 45, 160)\n            }\n        }\n        g.font = Font(FONT_NAME, Font.PLAIN, 18)\n    }\n}\n\nprivate val FONT_NAME = \"Arial\"\nprivate val TILE_SIZE = 64\nprivate val TILES_MARGIN = 16\n\nabstract class GameSettings(val name: String, val backgroundColor: Color) {\n    abstract fun getBackgroundColor(value: Int): Color\n    abstract fun getForegroundColor(value: Int): Color\n}\n\nfun playGame(game: Game, settings: GameSettings) {\n    with(JFrame()) {\n        title = settings.name\n        defaultCloseOperation = WindowConstants.EXIT_ON_CLOSE\n        setSize(340, 400)\n        isResizable = false\n\n        add(PlayGame(game, settings))\n\n        setLocationRelativeTo(null)\n        isVisible = true\n    }\n}",
          "placeholders" : [ ]
        },
        "src/games/ui/PlayGame2048.kt" : {
          "name" : "src/games/ui/PlayGame2048.kt",
          "text" : "package games.ui\n\nimport games.game2048.newGame2048\nimport java.awt.Color\n\nobject Game2048Settings : GameSettings(\"Game 2048\", Color(0xbbada0)) {\n    private val emptyColor = Color(0xcdc1b4)\n    private val colors: Map<Int, Color> = run {\n        val colors = listOf(\n                0xeee4da, 0xede0c8, 0xf2b179, 0xf59563, 0xf67c5f, 0xf65e3b,\n                0xedcf72, 0xedcc61, 0xedc850, 0xedc53f, 0xedc22e)\n\n        val values: List<Int> = (1..11).map { Math.pow(2.0, it.toDouble()).toInt() }\n        values.zip(colors.map { Color(it) }).toMap()\n    }\n\n    override fun getBackgroundColor(value: Int) = colors[value] ?: emptyColor\n    override fun getForegroundColor(value: Int) = if (value < 16) Color(0x776e65) else Color(0xf9f6f2)\n}\n\n\nfun main(args: Array<String>) {\n    playGame(newGame2048(), Game2048Settings)\n}",
          "placeholders" : [ ]
        },
        "src/games/ui/PlayGameOfFifteen.kt" : {
          "name" : "src/games/ui/PlayGameOfFifteen.kt",
          "text" : "package games.ui\n\nimport games.gameOfFifteen.newGameOfFifteen\nimport java.awt.Color\n\nobject GameOfFifteenSettings : GameSettings(\"Game of fifteen\", Color(0x909090)) {\n    private val emptyColor = Color(0x787878)\n    private val firstColor = Color(0xC8C8C8)\n    private val secondColor = Color(0xCCCCFF)\n    private val foregroundColor = Color(0x545AA7)\n\n    override fun getBackgroundColor(value: Int) = when {\n        value == 0 -> emptyColor\n        ((value - 1) / 4 + value % 4) % 2 == 0 -> firstColor\n        else -> secondColor\n    }\n\n    override fun getForegroundColor(value: Int) = foregroundColor\n}\n\nfun main(args: Array<String>) {\n    playGame(newGameOfFifteen(), GameOfFifteenSettings)\n}",
          "placeholders" : [ ]
        },
        "test/TestGameBoard.kt" : {
          "name" : "test/TestGameBoard.kt",
          "text" : "package games.board\n\nimport board.GameBoard\nimport board.createGameBoard\nimport org.junit.Assert\nimport org.junit.Test\n\nclass TestGameBoard {\n    operator fun <T> GameBoard<T>.get(i: Int, j: Int) = get(getCell(i, j))\n    operator fun <T> GameBoard<T>.set(i: Int, j: Int, value: T) = set(getCell(i, j), value)\n\n    @Test\n    fun testGetAndSetElement() {\n        val gameBoard = createGameBoard<Char>(2)\n        gameBoard[1, 1] = 'a'\n        Assert.assertEquals('a', gameBoard[1, 1])\n    }\n\n    @Test\n    fun testFilter() {\n        val gameBoard = createGameBoard<Char>(2)\n        gameBoard[1, 1] = 'a'\n        gameBoard[1, 2] = 'b'\n        val cells = gameBoard.filter { it == 'a' }\n        Assert.assertEquals(1, cells.size)\n        val cell = cells.first()\n        Assert.assertEquals(1, cell.i)\n        Assert.assertEquals(1, cell.j)\n    }\n\n    @Test\n    fun testAll() {\n        val gameBoard = createGameBoard<Char>(2)\n        gameBoard[1, 1] = 'a'\n        gameBoard[1, 2] = 'a'\n        Assert.assertFalse(gameBoard.all { it == 'a' })\n        gameBoard[2, 1] = 'a'\n        gameBoard[2, 2] = 'a'\n        Assert.assertTrue(gameBoard.all { it == 'a' })\n    }\n\n    @Test\n    fun testAny() {\n        val gameBoard = createGameBoard<Char>(2)\n        gameBoard[1, 1] = 'a'\n        gameBoard[1, 2] = 'b'\n        Assert.assertTrue(gameBoard.any { it in 'a'..'b' })\n        Assert.assertTrue(gameBoard.any { it == null })\n    }\n}",
          "placeholders" : [ ]
        },
        "test/TestSquareBoard.kt" : {
          "name" : "test/TestSquareBoard.kt",
          "text" : "package games.board\n\nimport board.Cell\nimport board.createSquareBoard\nimport board.Direction.*\nimport org.junit.Assert\nimport org.junit.Test\n\nclass TestSquareBoard {\n\n    private fun Cell?.asString() = if (this != null) \"($i, $j)\" else \"\"\n\n    private fun Collection<Cell>.asString() = joinToString(prefix = \"[\", postfix = \"]\") { it.asString() }\n\n    @Test\n    fun testAllCells() {\n        val board = createSquareBoard(2)\n        val cells = board.getAllCells().sortedWith(compareBy<Cell> { it.i }.thenBy { it.j })\n        Assert.assertEquals(\"[(1, 1), (1, 2), (2, 1), (2, 2)]\", cells.asString())\n    }\n\n    @Test\n    fun testCell() {\n        val board = createSquareBoard(2)\n        val cell = board.getCellOrNull(1, 2)\n        Assert.assertEquals(1, cell?.i)\n        Assert.assertEquals(2, cell?.j)\n    }\n\n    @Test\n    fun testNoCell() {\n        val board = createSquareBoard(2)\n        val cell = board.getCellOrNull(3, 3)\n        Assert.assertEquals(null, cell)\n    }\n\n    @Test\n    fun testRow() {\n        val board = createSquareBoard(2)\n        val row = board.getRow(1, 1..2)\n        Assert.assertEquals(\"[(1, 1), (1, 2)]\", row.asString())\n    }\n\n    @Test\n    fun testRowReversed() {\n        val board = createSquareBoard(2)\n        val row = board.getRow(1, 2 downTo 1)\n        Assert.assertEquals(\"[(1, 2), (1, 1)]\", row.asString())\n    }\n\n    @Test\n    fun testRowWrongRange() {\n        val board = createSquareBoard(2)\n        val row = board.getRow(1, 1..2)\n        Assert.assertEquals(\"[(1, 1), (1, 2)]\", row.asString())\n    }\n\n    @Test\n    fun testNeighbour() {\n        val board = createSquareBoard(2)\n        with(board) {\n            val cell = getCellOrNull(1, 1)\n            Assert.assertNotNull(cell)\n            Assert.assertEquals(null, cell!!.getNeighbour(UP))\n            Assert.assertEquals(null, cell.getNeighbour(LEFT))\n            Assert.assertEquals(\"(2, 1)\", cell.getNeighbour(DOWN).asString())\n            Assert.assertEquals(\"(1, 2)\", cell.getNeighbour(RIGHT).asString())\n        }\n    }\n}\n",
          "placeholders" : [ ]
        },
        "test/TestGame2048.kt" : {
          "name" : "test/TestGame2048.kt",
          "text" : "package games.game2048\n\nimport board.Cell\nimport board.Direction\nimport board.Direction.*\nimport board.GameBoard\nimport games.game.Game\nimport org.junit.Assert\nimport org.junit.Test\n\nclass TestGame2048 {\n    private fun Game.asString() =\n            (1..4).joinToString(\"\\n\") { i ->\n                (1..4).joinToString(\" \") { j ->\n                    \"${get(i, j) ?: \"-\"}\"\n                }\n            }\n\n    class TestGame2048Initializer(moves: List<Move>) : Game2048Initializer<Int> {\n        val iterator = moves.iterator()\n        override fun nextValue(board: GameBoard<Int?>): Pair<Cell, Int> {\n            val move = iterator.next()\n            return board.getCell(move.position.first, move.position.second) to move.value\n        }\n    }\n\n    private fun testGame(moves: List<Move>) {\n        val game = newGame2048(TestGame2048Initializer(moves))\n        game.initialize()\n        run {\n            // checking the state after initialization\n            val first = moves[0]\n            val second = moves[1]\n            Assert.assertEquals(\"Wrong result after board initialization \" +\n                    \"by '${first.value}' at ${first.cell} and \" +\n                    \"'${second.value}' at ${second.cell}\",\n                    second.board, game.asString())\n        }\n\n        for ((index, move) in moves.withIndex()) {\n            if (move.direction == null) continue\n            // checking the state after each move\n            game.processMove(move.direction)\n            val prev = moves[index - 1].board\n            Assert.assertEquals(\"Wrong result after moving ${move.direction} \" +\n                    \"and then adding '${move.value}' to ${move.cell} \" +\n                    \"for\\n$prev\\n\",\n                    move.board, game.asString())\n        }\n    }\n\n    data class Move(\n            val position: Pair<Int, Int>,\n            val value: Int,\n            val direction: Direction?,\n            val initialBoard: String\n    ) {\n        val cell: String\n            get() = \"Cell(${position.first}, ${position.second})\"\n\n        val board: String = initialBoard.trimMargin()\n    }\n\n    @Test\n    fun testMoves() {\n        testGame(listOf(\n                Move(Pair(1, 1), 2, null, \"\"\"\n            |2 - - -\n            |- - - -\n            |- - - -\n            |- - - -\"\"\"),\n                Move(Pair(1, 4), 2, null, \"\"\"\n            |2 - - 2\n            |- - - -\n            |- - - -\n            |- - - -\"\"\"),\n                Move(Pair(3, 2), 4, RIGHT, \"\"\"\n            |- - - 4\n            |- - - -\n            |- 4 - -\n            |- - - -\"\"\"),\n                Move(Pair(4, 2), 2, UP, \"\"\"\n            |- 4 - 4\n            |- - - -\n            |- - - -\n            |- 2 - -\"\"\"),\n                Move(Pair(2, 2), 2, LEFT, \"\"\"\n            |8 - - -\n            |- 2 - -\n            |- - - -\n            |2 - - -\"\"\"),\n                Move(Pair(4, 4), 2, DOWN, \"\"\"\n            |- - - -\n            |- - - -\n            |8 - - -\n            |2 2 - 2\"\"\"),\n                Move(Pair(3, 3), 2, RIGHT, \"\"\"\n            |- - - -\n            |- - - -\n            |- - 2 8\n            |- - 2 4\"\"\"),\n                Move(Pair(1, 2), 4, DOWN, \"\"\"\n            |- 4 - -\n            |- - - -\n            |- - - 8\n            |- - 4 4\"\"\"),\n                Move(Pair(3, 1), 2, RIGHT, \"\"\"\n            |- - - 4\n            |- - - -\n            |2 - - 8\n            |- - - 8\"\"\"),\n                Move(Pair(3, 3), 2, DOWN, \"\"\"\n            |- - - -\n            |- - - -\n            |- - 2 4\n            |2 - - 16\"\"\"),\n                Move(Pair(2, 3), 2, DOWN, \"\"\"\n            |- - - -\n            |- - 2 -\n            |- - - 4\n            |2 - 2 16\"\"\"),\n                Move(Pair(1, 4), 2, RIGHT, \"\"\"\n            |- - - 2\n            |- - - 2\n            |- - - 4\n            |- - 4 16\"\"\"),\n                Move(Pair(3, 2), 2, LEFT, \"\"\"\n            |2 - - -\n            |2 - - -\n            |4 2 - -\n            |4 16 - -\"\"\"),\n                Move(Pair(1, 3), 2, DOWN, \"\"\"\n            |- - 2 -\n            |- - - -\n            |4 2 - -\n            |8 16 - -\"\"\")\n        ))\n    }\n}",
          "placeholders" : [ ]
        },
        "test/TestGame2048Helper.kt" : {
          "name" : "test/TestGame2048Helper.kt",
          "text" : "package games.game2048\n\nimport org.junit.Assert\nimport org.junit.Test\n\nclass TestGame2048Helper {\n    @Test\n    fun testSample1() = testMerge(listOf(\"a\", \"a\", \"b\"), listOf(\"aa\", \"b\"))\n\n    @Test\n    fun testSample2() = testMerge(listOf(\"a\", null), listOf(\"a\"))\n\n\n    @Test\n    fun testSample3() = testMerge(listOf(\"b\", null, \"a\", \"a\"), listOf(\"b\", \"aa\"))\n\n    @Test\n    fun testSample4() = testMerge(listOf(\"a\", \"a\", null, \"a\"), listOf(\"aa\", \"a\"))\n\n    @Test\n    fun testSample5() = testMerge(listOf(\"a\", null, \"a\", \"a\"), listOf(\"aa\", \"a\"))\n\n    private fun testMerge(input: List<String?>, expected: List<String?>) {\n        val result = input.moveAndMergeEqual { it.repeat(2) }\n        Assert.assertEquals(\"Wrong result for $input.moveAndMergeEqual()\",\n                expected, result)\n    }\n}",
          "placeholders" : [ ]
        },
        "test/TestGameOfFifteen.kt" : {
          "name" : "test/TestGameOfFifteen.kt",
          "text" : "package games.gameOfFifteen\n\nimport board.Direction\nimport board.Direction.*\nimport games.game.Game\nimport org.junit.Assert\nimport org.junit.Test\n\nclass TestGameOfFifteen {\n    private fun Game.asString() =\n            (1..4).joinToString(\"\\n\") { i ->\n                (1..4).joinToString(\" \") { j ->\n                    get(i, j)?.let { \"%2d\".format(it) } ?: \" -\"\n                }\n            }\n\n    class TestGameInitializer(\n            override val initialPermutation: List<Int>\n    ) : GameOfFifteenInitializer\n\n    private fun testGame(initialPermutation: List<Int>, moves: List<Move>) {\n        val game = newGameOfFifteen(TestGameInitializer(initialPermutation))\n        game.initialize()\n\n        for ((index, move) in moves.withIndex()) {\n            if (move.direction == null) continue\n            // checking the state after each move\n            Assert.assertTrue(\"The move for game of fifteen should be always possible\", game.canMove())\n            game.processMove(move.direction)\n            val prev = moves[index - 1].board\n            Assert.assertEquals(\"Wrong result after pressing ${move.direction} \" +\n                    \"for\\n$prev\\n\",\n                    move.board, game.asString())\n        }\n    }\n\n    data class Move(\n            val direction: Direction?,\n            val initialBoard: String\n    ) {\n        val board: String = initialBoard.trimMargin()\n    }\n\n    @Test\n    fun testMoves() {\n        testGame(listOf(3, 6, 13, 15, 7, 5, 8, 4, 14, 11, 12, 1, 10, 9, 2),\n                listOf(\n                        Move(null, \"\"\"\n            | 3  6 13 15\n            | 7  5  8  4\n            |14 11 12  1\n            |10  9  2  -\"\"\"),\n                        Move(RIGHT, \"\"\"\n            | 3  6 13 15\n            | 7  5  8  4\n            |14 11 12  1\n            |10  9  -  2\"\"\"),\n                        Move(DOWN, \"\"\"\n            | 3  6 13 15\n            | 7  5  8  4\n            |14 11  -  1\n            |10  9 12  2\"\"\"),\n                        Move(LEFT, \"\"\"\n            | 3  6 13 15\n            | 7  5  8  4\n            |14 11  1  -\n            |10  9 12  2\"\"\"),\n                        Move(UP, \"\"\"\n            | 3  6 13 15\n            | 7  5  8  4\n            |14 11  1  2\n            |10  9 12  -\"\"\"),\n                        Move(RIGHT, \"\"\"\n            | 3  6 13 15\n            | 7  5  8  4\n            |14 11  1  2\n            |10  9  - 12\"\"\")\n                ))\n    }\n\n    @Test\n    fun testWinning() {\n        val game = newGameOfFifteen(TestGameInitializer(\n                (1..15).toList()))\n        game.initialize()\n        Assert.assertTrue(\"The player should win when the numbers are in order\",\n                game.hasWon())\n    }\n}",
          "placeholders" : [ ]
        },
        "test/TestGameOfFifteenHelper.kt" : {
          "name" : "test/TestGameOfFifteenHelper.kt",
          "text" : "package games.gameOfFifteen\n\nimport org.junit.Assert\nimport org.junit.Test\n\nclass TestGameOfFifteenHelper {\n    private fun testPermutation(permutation: List<Int>, isEven: Boolean) {\n        Assert.assertEquals(\"This permutation should be ${if (isEven) \"even\" else \"odd\"}: $permutation\", isEven,\n                isEven(permutation))\n    }\n\n    @Test\n    fun testExample0() = testPermutation((1..15).toList(), isEven = true)\n\n    @Test\n    fun testExample1() = testPermutation(listOf(1, 2, 3, 4), isEven = true)\n\n    @Test\n    fun testExample2() = testPermutation(listOf(2, 1, 4, 3), isEven = true)\n\n    @Test\n    fun testExample3() = testPermutation(listOf(4, 3, 2, 1), isEven = true)\n\n    @Test\n    fun testExample5() = testPermutation(listOf(1, 2, 4, 3), isEven = false)\n\n    @Test\n    fun testExample6() = testPermutation(listOf(1, 4, 3, 2), isEven = false)\n}",
          "placeholders" : [ ]
        }
      },
      "test_files" : {
        "test/TestGameBoard.kt" : "package games.board\n\nimport board.GameBoard\nimport board.createGameBoard\nimport org.junit.Assert\nimport org.junit.Test\n\nclass TestGameBoard {\n    operator fun <T> GameBoard<T>.get(i: Int, j: Int) = get(getCell(i, j))\n    operator fun <T> GameBoard<T>.set(i: Int, j: Int, value: T) = set(getCell(i, j), value)\n\n    @Test\n    fun testGetAndSetElement() {\n        val gameBoard = createGameBoard<Char>(2)\n        gameBoard[1, 1] = 'a'\n        Assert.assertEquals('a', gameBoard[1, 1])\n    }\n\n    @Test\n    fun testFilter() {\n        val gameBoard = createGameBoard<Char>(2)\n        gameBoard[1, 1] = 'a'\n        gameBoard[1, 2] = 'b'\n        val cells = gameBoard.filter { it == 'a' }\n        Assert.assertEquals(1, cells.size)\n        val cell = cells.first()\n        Assert.assertEquals(1, cell.i)\n        Assert.assertEquals(1, cell.j)\n    }\n\n    @Test\n    fun testAll() {\n        val gameBoard = createGameBoard<Char>(2)\n        gameBoard[1, 1] = 'a'\n        gameBoard[1, 2] = 'a'\n        Assert.assertFalse(gameBoard.all { it == 'a' })\n        gameBoard[2, 1] = 'a'\n        gameBoard[2, 2] = 'a'\n        Assert.assertTrue(gameBoard.all { it == 'a' })\n    }\n\n    @Test\n    fun testAny() {\n        val gameBoard = createGameBoard<Char>(2)\n        gameBoard[1, 1] = 'a'\n        gameBoard[1, 2] = 'b'\n        Assert.assertTrue(gameBoard.any { it in 'a'..'b' })\n        Assert.assertTrue(gameBoard.any { it == null })\n    }\n}",
        "test/TestSquareBoard.kt" : "package games.board\n\nimport board.Cell\nimport board.createSquareBoard\nimport board.Direction.*\nimport org.junit.Assert\nimport org.junit.Test\n\nclass TestSquareBoard {\n\n    private fun Cell?.asString() = if (this != null) \"($i, $j)\" else \"\"\n\n    private fun Collection<Cell>.asString() = joinToString(prefix = \"[\", postfix = \"]\") { it.asString() }\n\n    @Test\n    fun testAllCells() {\n        val board = createSquareBoard(2)\n        val cells = board.getAllCells().sortedWith(compareBy<Cell> { it.i }.thenBy { it.j })\n        Assert.assertEquals(\"[(1, 1), (1, 2), (2, 1), (2, 2)]\", cells.asString())\n    }\n\n    @Test\n    fun testCell() {\n        val board = createSquareBoard(2)\n        val cell = board.getCellOrNull(1, 2)\n        Assert.assertEquals(1, cell?.i)\n        Assert.assertEquals(2, cell?.j)\n    }\n\n    @Test\n    fun testNoCell() {\n        val board = createSquareBoard(2)\n        val cell = board.getCellOrNull(3, 3)\n        Assert.assertEquals(null, cell)\n    }\n\n    @Test\n    fun testRow() {\n        val board = createSquareBoard(2)\n        val row = board.getRow(1, 1..2)\n        Assert.assertEquals(\"[(1, 1), (1, 2)]\", row.asString())\n    }\n\n    @Test\n    fun testRowReversed() {\n        val board = createSquareBoard(2)\n        val row = board.getRow(1, 2 downTo 1)\n        Assert.assertEquals(\"[(1, 2), (1, 1)]\", row.asString())\n    }\n\n    @Test\n    fun testRowWrongRange() {\n        val board = createSquareBoard(2)\n        val row = board.getRow(1, 1..2)\n        Assert.assertEquals(\"[(1, 1), (1, 2)]\", row.asString())\n    }\n\n    @Test\n    fun testNeighbour() {\n        val board = createSquareBoard(2)\n        with(board) {\n            val cell = getCellOrNull(1, 1)\n            Assert.assertNotNull(cell)\n            Assert.assertEquals(null, cell!!.getNeighbour(UP))\n            Assert.assertEquals(null, cell.getNeighbour(LEFT))\n            Assert.assertEquals(\"(2, 1)\", cell.getNeighbour(DOWN).asString())\n            Assert.assertEquals(\"(1, 2)\", cell.getNeighbour(RIGHT).asString())\n        }\n    }\n}\n",
        "test/TestGame2048.kt" : "package games.game2048\n\nimport board.Cell\nimport board.Direction\nimport board.Direction.*\nimport board.GameBoard\nimport games.game.Game\nimport org.junit.Assert\nimport org.junit.Test\n\nclass TestGame2048 {\n    private fun Game.asString() =\n            (1..4).joinToString(\"\\n\") { i ->\n                (1..4).joinToString(\" \") { j ->\n                    \"${get(i, j) ?: \"-\"}\"\n                }\n            }\n\n    class TestGame2048Initializer(moves: List<Move>) : Game2048Initializer<Int> {\n        val iterator = moves.iterator()\n        override fun nextValue(board: GameBoard<Int?>): Pair<Cell, Int> {\n            val move = iterator.next()\n            return board.getCell(move.position.first, move.position.second) to move.value\n        }\n    }\n\n    private fun testGame(moves: List<Move>) {\n        val game = newGame2048(TestGame2048Initializer(moves))\n        game.initialize()\n        run {\n            // checking the state after initialization\n            val first = moves[0]\n            val second = moves[1]\n            Assert.assertEquals(\"Wrong result after board initialization \" +\n                    \"by '${first.value}' at ${first.cell} and \" +\n                    \"'${second.value}' at ${second.cell}\",\n                    second.board, game.asString())\n        }\n\n        for ((index, move) in moves.withIndex()) {\n            if (move.direction == null) continue\n            // checking the state after each move\n            game.processMove(move.direction)\n            val prev = moves[index - 1].board\n            Assert.assertEquals(\"Wrong result after moving ${move.direction} \" +\n                    \"and then adding '${move.value}' to ${move.cell} \" +\n                    \"for\\n$prev\\n\",\n                    move.board, game.asString())\n        }\n    }\n\n    data class Move(\n            val position: Pair<Int, Int>,\n            val value: Int,\n            val direction: Direction?,\n            val initialBoard: String\n    ) {\n        val cell: String\n            get() = \"Cell(${position.first}, ${position.second})\"\n\n        val board: String = initialBoard.trimMargin()\n    }\n\n    @Test\n    fun testMoves() {\n        testGame(listOf(\n                Move(Pair(1, 1), 2, null, \"\"\"\n            |2 - - -\n            |- - - -\n            |- - - -\n            |- - - -\"\"\"),\n                Move(Pair(1, 4), 2, null, \"\"\"\n            |2 - - 2\n            |- - - -\n            |- - - -\n            |- - - -\"\"\"),\n                Move(Pair(3, 2), 4, RIGHT, \"\"\"\n            |- - - 4\n            |- - - -\n            |- 4 - -\n            |- - - -\"\"\"),\n                Move(Pair(4, 2), 2, UP, \"\"\"\n            |- 4 - 4\n            |- - - -\n            |- - - -\n            |- 2 - -\"\"\"),\n                Move(Pair(2, 2), 2, LEFT, \"\"\"\n            |8 - - -\n            |- 2 - -\n            |- - - -\n            |2 - - -\"\"\"),\n                Move(Pair(4, 4), 2, DOWN, \"\"\"\n            |- - - -\n            |- - - -\n            |8 - - -\n            |2 2 - 2\"\"\"),\n                Move(Pair(3, 3), 2, RIGHT, \"\"\"\n            |- - - -\n            |- - - -\n            |- - 2 8\n            |- - 2 4\"\"\"),\n                Move(Pair(1, 2), 4, DOWN, \"\"\"\n            |- 4 - -\n            |- - - -\n            |- - - 8\n            |- - 4 4\"\"\"),\n                Move(Pair(3, 1), 2, RIGHT, \"\"\"\n            |- - - 4\n            |- - - -\n            |2 - - 8\n            |- - - 8\"\"\"),\n                Move(Pair(3, 3), 2, DOWN, \"\"\"\n            |- - - -\n            |- - - -\n            |- - 2 4\n            |2 - - 16\"\"\"),\n                Move(Pair(2, 3), 2, DOWN, \"\"\"\n            |- - - -\n            |- - 2 -\n            |- - - 4\n            |2 - 2 16\"\"\"),\n                Move(Pair(1, 4), 2, RIGHT, \"\"\"\n            |- - - 2\n            |- - - 2\n            |- - - 4\n            |- - 4 16\"\"\"),\n                Move(Pair(3, 2), 2, LEFT, \"\"\"\n            |2 - - -\n            |2 - - -\n            |4 2 - -\n            |4 16 - -\"\"\"),\n                Move(Pair(1, 3), 2, DOWN, \"\"\"\n            |- - 2 -\n            |- - - -\n            |4 2 - -\n            |8 16 - -\"\"\")\n        ))\n    }\n}",
        "test/TestGame2048Helper.kt" : "package games.game2048\n\nimport org.junit.Assert\nimport org.junit.Test\n\nclass TestGame2048Helper {\n    @Test\n    fun testSample1() = testMerge(listOf(\"a\", \"a\", \"b\"), listOf(\"aa\", \"b\"))\n\n    @Test\n    fun testSample2() = testMerge(listOf(\"a\", null), listOf(\"a\"))\n\n\n    @Test\n    fun testSample3() = testMerge(listOf(\"b\", null, \"a\", \"a\"), listOf(\"b\", \"aa\"))\n\n    @Test\n    fun testSample4() = testMerge(listOf(\"a\", \"a\", null, \"a\"), listOf(\"aa\", \"a\"))\n\n    @Test\n    fun testSample5() = testMerge(listOf(\"a\", null, \"a\", \"a\"), listOf(\"aa\", \"a\"))\n\n    private fun testMerge(input: List<String?>, expected: List<String?>) {\n        val result = input.moveAndMergeEqual { it.repeat(2) }\n        Assert.assertEquals(\"Wrong result for $input.moveAndMergeEqual()\",\n                expected, result)\n    }\n}",
        "test/TestGameOfFifteen.kt" : "package games.gameOfFifteen\n\nimport board.Direction\nimport board.Direction.*\nimport games.game.Game\nimport org.junit.Assert\nimport org.junit.Test\n\nclass TestGameOfFifteen {\n    private fun Game.asString() =\n            (1..4).joinToString(\"\\n\") { i ->\n                (1..4).joinToString(\" \") { j ->\n                    get(i, j)?.let { \"%2d\".format(it) } ?: \" -\"\n                }\n            }\n\n    class TestGameInitializer(\n            override val initialPermutation: List<Int>\n    ) : GameOfFifteenInitializer\n\n    private fun testGame(initialPermutation: List<Int>, moves: List<Move>) {\n        val game = newGameOfFifteen(TestGameInitializer(initialPermutation))\n        game.initialize()\n\n        for ((index, move) in moves.withIndex()) {\n            if (move.direction == null) continue\n            // checking the state after each move\n            Assert.assertTrue(\"The move for game of fifteen should be always possible\", game.canMove())\n            game.processMove(move.direction)\n            val prev = moves[index - 1].board\n            Assert.assertEquals(\"Wrong result after pressing ${move.direction} \" +\n                    \"for\\n$prev\\n\",\n                    move.board, game.asString())\n        }\n    }\n\n    data class Move(\n            val direction: Direction?,\n            val initialBoard: String\n    ) {\n        val board: String = initialBoard.trimMargin()\n    }\n\n    @Test\n    fun testMoves() {\n        testGame(listOf(3, 6, 13, 15, 7, 5, 8, 4, 14, 11, 12, 1, 10, 9, 2),\n                listOf(\n                        Move(null, \"\"\"\n            | 3  6 13 15\n            | 7  5  8  4\n            |14 11 12  1\n            |10  9  2  -\"\"\"),\n                        Move(RIGHT, \"\"\"\n            | 3  6 13 15\n            | 7  5  8  4\n            |14 11 12  1\n            |10  9  -  2\"\"\"),\n                        Move(DOWN, \"\"\"\n            | 3  6 13 15\n            | 7  5  8  4\n            |14 11  -  1\n            |10  9 12  2\"\"\"),\n                        Move(LEFT, \"\"\"\n            | 3  6 13 15\n            | 7  5  8  4\n            |14 11  1  -\n            |10  9 12  2\"\"\"),\n                        Move(UP, \"\"\"\n            | 3  6 13 15\n            | 7  5  8  4\n            |14 11  1  2\n            |10  9 12  -\"\"\"),\n                        Move(RIGHT, \"\"\"\n            | 3  6 13 15\n            | 7  5  8  4\n            |14 11  1  2\n            |10  9  - 12\"\"\")\n                ))\n    }\n\n    @Test\n    fun testWinning() {\n        val game = newGameOfFifteen(TestGameInitializer(\n                (1..15).toList()))\n        game.initialize()\n        Assert.assertTrue(\"The player should win when the numbers are in order\",\n                game.hasWon())\n    }\n}",
        "test/TestGameOfFifteenHelper.kt" : "package games.gameOfFifteen\n\nimport org.junit.Assert\nimport org.junit.Test\n\nclass TestGameOfFifteenHelper {\n    private fun testPermutation(permutation: List<Int>, isEven: Boolean) {\n        Assert.assertEquals(\"This permutation should be ${if (isEven) \"even\" else \"odd\"}: $permutation\", isEven,\n                isEven(permutation))\n    }\n\n    @Test\n    fun testExample0() = testPermutation((1..15).toList(), isEven = true)\n\n    @Test\n    fun testExample1() = testPermutation(listOf(1, 2, 3, 4), isEven = true)\n\n    @Test\n    fun testExample2() = testPermutation(listOf(2, 1, 4, 3), isEven = true)\n\n    @Test\n    fun testExample3() = testPermutation(listOf(4, 3, 2, 1), isEven = true)\n\n    @Test\n    fun testExample5() = testPermutation(listOf(1, 2, 4, 3), isEven = false)\n\n    @Test\n    fun testExample6() = testPermutation(listOf(1, 4, 3, 2), isEven = false)\n}"
      },
      "description_text" : "## Game\n\nYour task is to implement two games: \n[Game 2048](https://en.wikipedia.org/wiki/2048_(video_game)) and\n[Game of Fifteen](https://en.wikipedia.org/wiki/15_puzzle).\nUse your implementation of the `GameBoard` interface from the previous task. \n\nAfter implementing the game you can play it yourself running `main` function in \n`ui/PlayGame2048` or `ui/PlayGameOfFifteen`.\n\n### Game 2048\n\nFirst, complete the tasks in `Game2048Helper.kt` (implementing the function\n`moveAndMergeEqual` declared in `Game2048Helper.kt`) and\nin `Game2048Initializer.kt` (generating new values randomly).\nThen, implement the utility functions declared in `Game2048.kt`.\nThe tests which you can run to check each function are specified in the comments\nnext to the function.\n\n### Game of Fifteen\n\nGame of Fifteen is solvable only if the initial permutation of numbers\nis [even](https://en.wikipedia.org/wiki/Parity_of_a_permutation).\nImplement first the function `isEven` (declared in `GameOfFifteenHelper.kt`)\nchecking whether a permutation is even or odd, and then use this function\nto produce only solvable permutations in `GameOfFifteenIntiializer.kt`.\n\nYou can use the following algorithm to check the given permutation.\nLet `P` is a permutation function on a range of numbers `1..n`.\nFor a pair `(i, j)` of elements such that `i < j` , if `P(i) > P(j)`,\nthen the permutation is said to invert the order of `(i, j)`.\nThe number of such inverted pairs is the _parity_ of the permutation.\nIf permutation inverts even number of such pairs it is an even permutation else\nit is an odd permutation.",
      "description_format" : "md",
      "additional_files" : {
        "partId" : {
          "text" : "fVVXo",
          "is_visible" : false
        },
        "assignmentKey" : {
          "text" : "ufQQSL2qEeioYgpHPBWO4A",
          "is_visible" : false
        }
      },
      "task_type" : "edu",
      "feedback_link" : {
        "link_type" : "CUSTOM",
        "link" : "https://www.coursera.org/learn/kotlin-for-java-developers/programming/NSid0/game-2048-game-of-fifteen/discussions"
      }
    } ],
    "type" : "lesson"
  }, {
    "id" : 0,
    "title" : "Edu additional materials",
    "unit_id" : 0,
    "task_list" : [ {
      "name" : "Edu additional materials",
      "stepic_id" : 0,
      "task_files" : { },
      "test_files" : { },
      "additional_files" : {
        "build.gradle" : {
          "text" : "buildscript {\n    ext.kotlin_version = '1.2.51'\n\n    repositories {\n        mavenCentral()\n    }\n\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n    }\n}\n\ndef printOutput(def output) {\n    return tasks.create(\"printOutput\") {\n        for (line in output.toString().readLines()) {\n            println \"#educational_plugin\" + line\n        }\n    }\n}\n\nsubprojects {\n    apply plugin: 'application'\n    apply plugin: 'java'\n    apply plugin: 'kotlin'\n\n    sourceCompatibility = 1.8\n\n    repositories {\n        mavenCentral()\n    }\n\n    dependencies {\n        compile \"org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version\"\n        testCompile group: 'junit', name: 'junit', version: '4.12'\n    }\n\n    compileKotlin.destinationDir = compileJava.destinationDir\n\n    compileKotlin {\n        kotlinOptions.jvmTarget = \"1.8\"\n    }\n    compileTestKotlin {\n        kotlinOptions.jvmTarget = \"1.8\"\n    }\n\n    sourceSets {\n        main {\n            kotlin.srcDir 'src'\n            java.srcDir 'src'\n        }\n        test {\n            kotlin.srcDir 'test'\n            java.srcDir 'test'\n        }\n    }\n\n    mainClassName = project.hasProperty(\"mainClass\") ? project.getProperty(\"mainClass\") : \"\"\n\n    test {\n        outputs.upToDateWhen { false }\n        afterTest { TestDescriptor test, TestResult result ->\n            if (result.resultType == TestResult.ResultType.FAILURE) {\n                def message = result.exception?.message ?: \"Wrong answer\"\n                def lines = message.readLines()\n                println \"#educational_plugin FAILED + \" + lines[0]\n                lines[1..-1].forEach { line ->\n                    println \"#educational_plugin\" + line\n                }\n                // we need this to separate output of different tests\n                println\n            }\n        }\n    }\n\n    def runOutput = new ByteArrayOutputStream()\n    tasks.run.setStandardOutput(runOutput)\n    tasks.run.doLast { printOutput(runOutput) }\n}\n\nproject(':util') {\n    dependencies {\n        compile group: 'junit', name: 'junit', version: '4.12'\n    }\n}\n\nconfigure(subprojects.findAll {it.name != 'util'}) {\n    dependencies {\n        compile project(':util').sourceSets.main.output\n        testCompile project(':util').sourceSets.test.output\n    }\n}\n\ntask wrapper(type: Wrapper) {\n    gradleVersion = '4.8'\n}\n",
          "is_visible" : false
        }
      },
      "task_type" : "edu",
      "feedback_link" : {
        "link_type" : "STEPIK"
      }
    } ],
    "type" : "lesson"
  } ],
  "version" : 7
}